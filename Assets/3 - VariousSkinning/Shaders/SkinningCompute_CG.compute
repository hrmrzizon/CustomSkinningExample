/*
    referred site for dual quaternion : http://donw.io/post/dual-quaternion-skinning/ , http://developer.download.nvidia.com/SDK/10.5/direct3d/screenshots/samples/QuaternionSkinning.html
*/

CGPROGRAM

#pragma kernel LinearBlendCompute
#pragma kernel DualQuaternionBlendCompute
/*
 *  LinearBlendSkinning Data
 */
StructuredBuffer<float4x4> currentPoseMatrixBuffer;
StructuredBuffer<float4x4> restPoseMatrixBuffer;

/*
 *  per-vertex data layout
 */
struct VertexInfo
{
    float4 position;
    float4 normal;
    float2 uv;
};

/*
 *  bone-info data layout
 */
struct BoneInfoPerVertex
{
    float4 weight;
    int4 index;
};

/*
 *  Mesh source and bone weights and index
 */
StructuredBuffer<VertexInfo> meshBuffer;
StructuredBuffer<BoneInfoPerVertex> boneInfoBuffer;

/*
 *  Converted mesh data;
 */
RWStructuredBuffer<VertexInfo> meshStream;

cbuffer Config
{
    uint vertexCount;
}

inline float4x4 GetCurrentPoseMatrix(int boneIndex)
{
    return currentPoseMatrixBuffer[boneIndex];
}

inline float4x4 GetRestPoseMatrix(int boneIndex)
{
    return restPoseMatrixBuffer[boneIndex];
}

#define MAX_THREAD_ID 512

[numthreads(MAX_THREAD_ID, 1, 1)]
void LinearBlendCompute(uint3 threadID : SV_DispatchThreadID)
{
    for (uint realVertexID = threadID[0]; realVertexID < vertexCount; realVertexID += MAX_THREAD_ID)
    {
        float4x4 
            transformMatrix = GetCurrentPoseMatrix(boneInfoBuffer[realVertexID].index[0]) * boneInfoBuffer[realVertexID].weight[0],
            restPoseTransformMatrix = GetRestPoseMatrix(boneInfoBuffer[realVertexID].index[0]) * boneInfoBuffer[realVertexID].weight[0];

        if (boneInfoBuffer[realVertexID].weight[1] > 0)
        {
            transformMatrix += GetCurrentPoseMatrix(boneInfoBuffer[realVertexID].index[1]) * boneInfoBuffer[realVertexID].weight[1];
            restPoseTransformMatrix += GetRestPoseMatrix(boneInfoBuffer[realVertexID].index[1]) * boneInfoBuffer[realVertexID].weight[1];
        }
            
        if (boneInfoBuffer[realVertexID].weight[2] > 0)
        {
            transformMatrix += GetCurrentPoseMatrix(boneInfoBuffer[realVertexID].index[2]) * boneInfoBuffer[realVertexID].weight[2];
            restPoseTransformMatrix += GetRestPoseMatrix(boneInfoBuffer[realVertexID].index[2]) * boneInfoBuffer[realVertexID].weight[2];
        }
        
        if (boneInfoBuffer[realVertexID].weight[3] > 0)
        {
            transformMatrix += GetCurrentPoseMatrix(boneInfoBuffer[realVertexID].index[3]) * boneInfoBuffer[realVertexID].weight[3];
            restPoseTransformMatrix += GetRestPoseMatrix(boneInfoBuffer[realVertexID].index[3]) * boneInfoBuffer[realVertexID].weight[3];
        }
        
        transformMatrix = mul(transformMatrix, restPoseTransformMatrix);

        meshStream[realVertexID].position =
                                        mul(
					                        transformMatrix,
					                        float4(meshBuffer[realVertexID].position.xyz, 1)
				                        );
        meshStream[realVertexID].normal =
                                        mul(
					                        transformMatrix,
					                        float4(meshBuffer[realVertexID].normal.xyz, 1)
				                        );
        meshStream[realVertexID].uv = meshBuffer[realVertexID].uv;
    }
}

#include <DualQuaternion.cginc>

StructuredBuffer<DQ> currentPoseDQBuffer;
StructuredBuffer<DQ> restPoseDQBuffer;

inline DQ GetCurrentPoseDQ(int boneIndex)
{
    return currentPoseDQBuffer[boneIndex];
}

inline DQ GetRestPoseDQ(int boneIndex)
{
    return restPoseDQBuffer[boneIndex];
}

[numthreads(MAX_THREAD_ID, 1, 1)]
void DualQuaternionBlendCompute(uint3 threadID : SV_DispatchThreadID)
{
    for (uint realVertexID = threadID[0]; realVertexID < vertexCount; realVertexID += MAX_THREAD_ID)
    {
        BoneInfoPerVertex info = boneInfoBuffer[realVertexID];

        DQ	curPoseDQ = multiply(GetCurrentPoseDQ(info.index[0]), info.weight[0]),
            restPoseDQ = multiply(GetRestPoseDQ(info.index[0]), info.weight[0]),
            poseDQBuffer, otherRestPoseDQ;

        if (boneInfoBuffer[realVertexID].weight[1] > 0)
        {
            poseDQBuffer = GetCurrentPoseDQ(info.index[1]);

            if (dot(curPoseDQ.real, poseDQBuffer.real) >= 0)
                curPoseDQ = add(curPoseDQ, multiply(poseDQBuffer, info.weight[1]));
            else
                curPoseDQ = minus(curPoseDQ, multiply(poseDQBuffer, info.weight[1]));

            poseDQBuffer = GetRestPoseDQ(info.index[1]);
            
			if (dot(restPoseDQ.real, poseDQBuffer.real) >= 0)
				restPoseDQ = add(restPoseDQ, multiply(poseDQBuffer, info.weight[1]));
            else
                restPoseDQ = minus(restPoseDQ, multiply(poseDQBuffer, info.weight[1]));
        }
            
        if (boneInfoBuffer[realVertexID].weight[2] > 0)
        {
			poseDQBuffer = GetCurrentPoseDQ(info.index[2]);

			if (dot(curPoseDQ.real, poseDQBuffer.real) >= 0)
				curPoseDQ = add(curPoseDQ, multiply(poseDQBuffer, info.weight[2]));
			else
				curPoseDQ = minus(curPoseDQ, multiply(poseDQBuffer, info.weight[2]));

			poseDQBuffer = GetRestPoseDQ(info.index[2]);

			if (dot(restPoseDQ.real, poseDQBuffer.real) >= 0)
				restPoseDQ = add(restPoseDQ, multiply(poseDQBuffer, info.weight[2]));
			else
				restPoseDQ = minus(restPoseDQ, multiply(poseDQBuffer, info.weight[2]));
		}
        
        if (boneInfoBuffer[realVertexID].weight[3] > 0)
        {
			poseDQBuffer = GetCurrentPoseDQ(info.index[3]);

			if (dot(curPoseDQ.real, poseDQBuffer.real) >= 0)
				curPoseDQ = add(curPoseDQ, multiply(poseDQBuffer, info.weight[3]));
			else
				curPoseDQ = minus(curPoseDQ, multiply(poseDQBuffer, info.weight[3]));

			poseDQBuffer = GetRestPoseDQ(info.index[3]);

			if (dot(restPoseDQ.real, poseDQBuffer.real) >= 0)
				restPoseDQ = add(restPoseDQ, multiply(poseDQBuffer, info.weight[3]));
			else
				restPoseDQ = minus(restPoseDQ, multiply(poseDQBuffer, info.weight[3]));
		}

        //*
        curPoseDQ = mulDQ(restPoseDQ, curPoseDQ);

        meshStream[realVertexID].position = float4(transformPositionByDQ(curPoseDQ, meshBuffer[realVertexID].position.xyz), 0);
        meshStream[realVertexID].normal = float4(transformPositionByDQ(curPoseDQ, meshBuffer[realVertexID].normal.xyz), 0);
        meshStream[realVertexID].uv = meshBuffer[realVertexID].uv;
        /*/
        
        curPoseDQ = mulDQ(restPoseDQ, curPoseDQ);
        float4x4 convertedMatrix = DQToMatrix(curPoseDQ);

        meshStream[realVertexID].position = mul(convertedMatrix, meshBuffer[realVertexID].position);
        meshStream[realVertexID].normal = mul(convertedMatrix, meshBuffer[realVertexID].normal);
        meshStream[realVertexID].uv = meshBuffer[realVertexID].uv;
        //*/
    }
}
 
ENDCG
